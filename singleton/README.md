# 单例模式

    当系统中只需要一个实例对象或者系统中只允许一个公共访问点，
    除了这个公共访问点外，不能通过其他访问点访问该实例时，可以使用单例模式。

### 特点

1. 只有一个实例。 

2. 自我实例化。 

3. 提供全局访问点。

### 优点

    节约系统资源、提高了系统效率，同时也能够严格控制客户对它的访问。
    该类只存在一个实例，节省系统资源；对于需要频繁创建销毁的对象，使用单例模式可以提高系统性能。
    
### 缺点
    
    因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，
    同时也没有抽象类，所以扩展起来有一定的困难。
    不能外部实例化（new），调用人员不清楚调用哪个方法获取实例时会感到迷惑，尤其当看不到源代码时。
    
#### 实现原理(保证实例的唯一)

1. 防止外部初始化

2. 由类本身进行实例化

3. 保证实例化一次

4. 对外提供获取实例的方法

5. 线程安全

#### 具体实现

1. 饿汉模式

    > HungrySingleton.java  最简单最安全的实现方式，在使用频率较高的情况下考虑
    
2. 懒汉模式

    > LazyEnumSingleton.java 枚举方式实现，天然线程安全，可防止反射生成实例，强烈推荐使用

    > LazyStaticInnerClassSingleton.java 私有静态内部类方式实现，简单容易，建议使用

    > LazyDoubleCheckSingleton.java 双重检查方式实现，在首次并发的情况下会进入同步锁，后期每次都要进行非空验证，代码写的花里胡哨的，但是考虑到实际情况并不建议使用

    > LazyLockSingleton.java 同步锁方式实现，严重影响效率，不建议使用
    
    > LazySingletonErrorDemo.java 最简单的懒汉模式，线程不安全，不建议使用


*********

**以上六种实现方式仅推荐三种，1：饿汉模式，2：枚举模式，3：私有静态内部类模式，其它方式均有各自的不如意的地方**
        